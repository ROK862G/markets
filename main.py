import numpy as np
import pandas as pd
import matplotlib.pyplot as plt
from sklearn.ensemble import RandomForestClassifier
from sklearn.model_selection import train_test_split
from utilities import *

# Define the symbol for USD/EUR
symbol = input("Enter the currency pair/symbol (e.g., 'USDZAR'): ").upper()

data = get_polygon_data(symbol)

# Extract and organize the data
if data is not None:
    model = load_model(symbol)

    # Define features (e.g., moving averages)
    data['SMA50'] = data['Close'].rolling(window=50).mean()
    data['SMA200'] = data['Close'].rolling(window=200).mean()

    # Create labels for trading signals
    data['Signal'] = 0  # 0 for no signal, 1 for buy, -1 for sell
    data.loc[data['SMA50'] > data['SMA200'], 'Signal'] = 1  # Golden Cross
    data.loc[data['SMA50'] < data['SMA200'], 'Signal'] = -1  # Death Cross

    # Prepare input data for machine learning
    X = data[['SMA50', 'SMA200']].dropna()  # Features
    y = data['Signal'].loc[X.index]  # Labels

    # Split data into training and testing sets
    if len(X) > 0:
        X_train, X_test, y_train, y_test = train_test_split(X, y, test_size=0.2, random_state=42)

        if model is None:
            # Train a machine learning model (Random Forest in this case)
            model = RandomForestClassifier(
                n_estimators=150,
                random_state=82,
                min_samples_leaf=5,
                min_weight_fraction_leaf=0.45,
                criterion='entropy',
                max_features='log2',
                warm_start=True,
                verbose=1,
                ccp_alpha=0.8,
            )

            model.fit(X_train, y_train)

            save_model(model, symbol)

        # Make predictions on the testing set
        y_pred = model.predict(X_test)

        # Implement a basic trading strategy
        data['Position'] = 0
        data.loc[X.index[-len(y_test):], 'Position'] = y_pred
        data['Position'] = data['Position'].shift(1)  # Shift to avoid look-ahead bias

        # Calculate returns based on trading decisions
        data['Returns'] = data['Close'] * data['Position']
        data['Cumulative_Returns'] = data['Returns'].cumsum()

        # Visualize the results, backtest, and evaluate performance
        # (You can use libraries like Matplotlib and Pandas for this)

        # Visualize the results
        plt.figure(figsize=(12, 6))
        plt.plot(data.index, data['Close'], label='Close Price', color='black')
        plt.plot(data.index, data['SMA50'], label='SMA50', color='blue', linestyle='--')
        plt.plot(data.index, data['SMA200'], label='SMA200', color='red', linestyle='--')
        plt.legend(loc='upper left')
        plt.title('USD/EUR Price and Moving Averages')
        plt.xlabel('Date')
        plt.ylabel('Price')
        plt.show()

        # Backtest the trading strategy
        data['Strategy_Returns'] = data['Position'].shift(1) * data['Returns']
        data['Cumulative_Strategy_Returns'] = data['Strategy_Returns'].cumsum()

        # Evaluate performance
        total_returns = data['Cumulative_Returns'].iloc[-1]
        strategy_returns = data['Cumulative_Strategy_Returns'].iloc[-1]
        strategy_returns_percent = strategy_returns / data['Cumulative_Returns'].iloc[0] * 100

        print(f"Total Returns: {total_returns:.2f}")
        print(f"Strategy Returns: {strategy_returns:.2f}")
        print(f"Strategy Returns (%) : {strategy_returns_percent:.2f}%")

        # Plot the strategy returns
        plt.figure(figsize=(12, 6))
        plt.plot(data.index, data['Cumulative_Returns'], label='Buy and Hold', color='black')
        plt.plot(data.index, data['Cumulative_Strategy_Returns'], label='Strategy', color='blue')
        plt.legend(loc='upper left')
        plt.title('Cumulative Returns')
        plt.xlabel('Date')
        plt.ylabel('Returns')
        plt.show()

        # Analyze the last signal generated by the strategy
        last_signal = data['Signal'].iloc[-1]

        # Define trading opportunity parameters
        if last_signal == 1:
            entry_price = data['Close'].iloc[-1]  # Current closing price for entry
            exit_price = data['Close'].iloc[-2]  # Previous closing price for exit
            stop_loss = entry_price * 0.98  # Set a stop-loss 2% below the entry price
            take_profit = entry_price * 1.02  # Set a take-profit 2% above the entry price

            # Provide a trading recommendation
            print("#########################")
            print("Trading Opportunity: Buy")
            print(f"Entry Price: {entry_price:.2f}")
            print(f"Exit Price (Previous Close): {exit_price:.2f}")
            print(f"Stop-loss: {stop_loss:.2f}")
            print(f"Take Profit: {take_profit:.2f}")

        elif last_signal == -1:
            entry_price = data['Close'].iloc[-1]  # Current closing price for entry
            exit_price = data['Close'].iloc[-2]  # Previous closing price for exit
            stop_loss = entry_price * 1.02  # Set a stop-loss 2% above the entry price
            take_profit = entry_price * 0.98  # Set a take-profit 2% below the entry price

            # Provide a trading recommendation
            print("#########################")
            print("Trading Opportunity: Sell")
            print(f"Entry Price: {entry_price:.2f}")
            print(f"Exit Price (Previous Close): {exit_price:.2f}")
            print(f"Stop-loss: {stop_loss:.2f}")
            print(f"Take Profit: {take_profit:.2f}")

        else:
            print("No trading signal at the moment.")

        # Visualize the results and performance as in your code
        # (You can use libraries like Matplotlib and Pandas for this)

        # Finally, consider risk management, capital allocation, and further model optimization.
    else:
        print(f"Not enough data for analysis, {data}")
